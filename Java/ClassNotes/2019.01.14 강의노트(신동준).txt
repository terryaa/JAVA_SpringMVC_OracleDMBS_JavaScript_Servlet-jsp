1020p6번째줄. URI은 볼것. 
	* 오류안남. 추상적으로 생성 됨.

URI - 인터넷주소에 대한 정보를 저장하면서 1021p스트림인데 경로를 지정해야 함. 경로대신에 뉴파일클래스를 넣던가. 생성자의 인자값은 FILE 클래스1032
	* 보조개념이라 네트워크를 쓰던지 파일을 쓰던지 해야함.

1037P
	* 기본 데이터 타입을 넣을 수 있다. 
	* 바이트스트림 자체가 바이트로 출력되기 때문에. DOUBLE단위로 넣다뺐다 할 수 있다.
	* ?

입력한대로 뽑아라. 즉 아웃풋한대로 인풋해라. 순서가 중요하다. (순서를 모르면 데이터 뽑기가 어렵기 때문.)Read.Write 지원 *특이한건 String인데 UTF로 진행함. 1039P정말 많이 사용하는건 프린트스트림
	* 기억하는게좋다

1041P - 그냥 넘어감1043p**진짜중요한 스트림인 Object스트림
	* 자바는 메모리에 생성된 객체를 파일 또는 네트워크로 출력할 수가 있다.
	* 객체는 문자가 아니기 때문에 바이트 기반 스트림으로 출력해야 한다.
	* 객체를 출력하기 위해서는 객체의 데이터(필드값)을 일렬로 늘어선 연속적인 바이트로 변경해야 하는데, 이것을 객체 직렬화라고 한다.
	* 반대로 파일에 저장되어 있거나 네트워크에서 전송된 객체를 읽을 수도 있는데, 입력스트림으로부터 읽어들인 연속적인 바이트를 객체로 복원하는 것을 역질렬화라고 한다. 


	* 1045P

		* Serializable - 직렬화 대상이 되는지 안되는지 검사함.
		* 

\**문자스트림 - 2바이트 체계로 진행.new InputStreamReader(new FileInputStream(path))이렇게 사용하는 이유
	* 파일리더를 사용해도 됨.
	* 근데 문자열이면 파일리더로 읽는게 더 나음. 
	* 그런데 리눅스 계열에서 소켓을 사용하는 API가 ByteStream이다.
	* 문자단위로 읽을 필요가 있다. (영상같은경우는 이렇게 사용하는게 아닌 인아웃스트림?을 사용해야함 - 버퍼도 써야 함.)
	* API를 주는애가 2바이트를 주면 고민할 필요가 없는데, 1바이트짜리 바이트 스트림을 주는거임. 

		* new InputStram~~이거말하는거임.
	* 그걸 문자로 변환해야 할 의무가 있음. 인풋스트림 리더를 제공을 받아서 사용하는데, InputStreamReader(new FileInputStream(path) << 이거 두개를 연결해준다고 해서 브릿지스트림이라고 한다.
	* 인풋스트림리더가 브릿지스트림이다. (연결해준다고해서)
	* 아웃풋스트림리더는 거의 안사용. 
	* 
	* 

		* InputStreamReader : 바이트를 문자로 변환시켜주는 스트림. << 브릿지 스트림이라고 한다. 
		* (대체하는건 스캐너가 있는데 아직 안했다.)

실기에서 I/O 사용하는거브릿지스트림, 오브젝트스트림 자바 직렬화가 무엇(what)인가요??
	* 자바 직렬화란 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술과 바이트로 변환된 데이터를 다시 객체로 변환하는 기술(역직렬화)을 아울러서 이야기합니다.
	* 

System 클래스(표준 입출력) : System.in, System.out, System.errJAVA에서는 스크린과 키보드를 통한 입출력 방법인 표준 입출력을 제공한다. 표준 입출력을 제공하는 클래스는 java.lang.System으로 멤버 변수인 in, out, err을 이용해서 표준 입력, 표준 출력, 표준 에러를 제공한다.1. System.inSystem.in은 InputStream 형태로 지정되어 있다. System 클래스는 자바 버추얼 머신을 구성하고 있는 표준 장치를 뜻하는 클래스이다. 자바 버추얼 머신은 그 자체가 완벽한 하나의 컴퓨터 플랫폼을 가정하고 있기 때문에 독립적으로 동작할 수 있는 구조를 표현하기 위하여 표준 입력과 표준 출력을 스스로의 System 클래스에 등록하여 사용한다.여기에서 주목해야 할 부분은 System.in 변수의 타입이 InputStream 이라는 점이다.InputStream 클래스는 최상위 클래스이면서 추상 클래스이다. 따라서 InputStream은 객체를 생성할 수 없는 클래스이다.[JAVA] ByteStream : InputStream / OutputStream그런데도 System.in은 실제로 객체가 존재하고 있으며 이를 통하여 키보드 입력을 받을 수 있다. 이것은 변수의 타입은 선조 클래스이지만 실제 객체는 후손 객체이다. 자연스러운 형 변환이 지원되기 때문에 가능하다.System.in을 통하여 접근되는 객체는 자바 버추얼 머신이 메모리로 올라오면서 미리 객체를 생성해 놓는, 대표적인 객체이다. 자료형이 InputStream이기 때문에 바이트 단위로만 입출력이 허용된다.키보드에서 입력하는 자료는 때에 따라서 두 바이트가 합쳐져야 의미를 가지는 경우가 있다. 그래서 System.in을 통하여 읽을 경우에는 영문과 한글의 처리를 분리해서 구성해야 제대로 인식할 수 있다. 2. System.outSystem.out 변수는 표준 출력 장치 객체를 가리키는 대표적인 출력 변수이다. 자바 언어를 처음 배우자마자 사용하는 문장 중 하나가 System.out.println() 메소드다.System.out은 PrintStream 타입으로 선언되어 있는데 PrintStream은 OutputStream 클래스의 후손 클래스로 Exception을 안전하게 처리한 메소드로만 구성되어 있다. 이런 이유로 System.out 을 이용하여 출력할 때는 try, catch 구문을 작성할 필요가 없다.영상엔 버퍼써야함printWriter
	* 내부적으로 바이트를 문자로 전송할 수 있는 브릿지 스트림을 내장하고 있으며, 
	* 버퍼도 내장하고 있다. Outputstreamwriter < 브릿지스트림
	* 버퍼는 플러쉬라는 메소드를 호출하고 있다. 







576p
프로세스
프로그램이 실행되는 상태. 


멀티테스킹
	* 
테스킹은 프로세스보다 높은 범위. CPU 및 메모리 자원을 프로세스마다 적절히 할당.
	* 
워드문서작업하다가 윈도우미디어플레이어 작동. (사실은 멀티프로세스)
	* 
A사용자가 작동하다가 B사용자로 넘어감



프로세스
	* 
껍데기. 하나의 프로세스로 처리를 하는 단위가 쓰레드. 
	* 
최소한의 단위는 쓰레드다.
	* 
메인프로그램 - 메인쓰레드
	* 
메인쓰레드 - 스택에 할당. 




멀티쓰레드
메인쓰레드 스택1
작업쓰레드2는 스택3
작업스레드1은 스택2

3개의 스텍을 가지고 있다. 
	* 
쓰레드를 3개를 돌리면 스택도 3개이다.(각각)



메인스레드가 종료되더라도 작업스레드가 계속 실행중이라면 프로세스는 종료되지 않는다.
	* 
프로세스는 죽은게 아님. 
	* 
그걸 예방하기 위해서 데몬을 만듬.
	* 
메인쓰레드에서 파생된 데몬이 작업스레드로 감. 데몬처리 -> 작업스레드를 끝냄.
	* 
리눅스에서는 백그라운드 내에서 작업함.




쓰레드는 프로세스가 최소 단위고 프로그램이 실행 될 때 작업을 한다.
	* 
프로세스를 실행하기 위한 JOB들로 이루어져 있다.
	* 
풀에서 각각의 TESK에서 완료를시켜줌. 




쓰레드가 실제 일을 할려고 할 때 메서드를 호출하는데 스텍에 쌓이는게 아니라 실행이 될 대만 별도의 스텍을 제공받음.



클래스가 쓰레드를 상속받아야함
일꾼(RUN) 설계



	* 
ex. 라면집

		* 
손님이 옴
		* 
자리에 앉음
		* 
주문을 받음. 
		* 
요리시작. 
		* 
손님에게 서빙하고
		* 
손님 감.
	* 
but 손님이 여러명이라면?

		* 
잠시 내 일을 도와줄만한 일꾼이 필요하다.
		* 
메인(요리)는 내가하고, 주문받는건 일꾼.
	* 
손님 3명을 기준

		* 
손님이 고르고있다
		* 
그럼 작업 불가능.
		* 
다음단계가 진행이 안된다.
	* 
별도의 일꾼이 왔다.

		* 
즉 자기만의 공간도 온 것이다. (자기만의 공간 - 자기만의 스택
		* 
메인에서도 자기만의 스택이 있고 일꾼도 자기만의 스택이 있다.
		* 
즉, 스레드는 작업공간을 가지고 있다.




*스레드를 생성하는 방법
	* 
extends Thread (상속)

		* 
모든 자원을 다 사용 가능하다
		* 
반드시 쓰레드에게 특징을 이해시켜줘야함. 
		* 
일꾼으로 보고 일을 시켜야하는데 그 일을 프로그래밍적인 알고리즘을 RUN에다가 넣어야 함.
	* 
EXTENDS THREAD 

		* 
자바에서는 상속은 다중상속이 안된다. 상속받은 클래스 안에서 스레드를 쓰고 싶다면
		* 
익명 쓰레드에서 사용이 가능하다. (익명내부클래스)





	* 
멀티스레드에서는

		* 
스레드에서는 순서가 없다. 경쟁상태다. (내가먼저 들어갈거야 하는 경쟁상태)

			* 
프로그램의 룰을 벗어나는경우가 생기는데 그걸 미연에 방지하고자 동기화라는 개념이 있다.
		* 
스레드생성방법 - EXTENDS 상송으로



					* 
익명클래스도있음
	* 
***thread.start

		* 
Class A extends Thread

			* 
public void run(){
			* 
xx
			* 
}
		* 
main{


                     1번수행>   A ref = new A();
                       2번수행>  ref.start( );


		* 
}






S
H
스택

100번지 NEW

(힙 이후에 되는 것)
ref.run()

	* 
메인스레드가 가지고 있는 그 스택에서 호출이 됨.
	* 
thread.start(); 호출
	* 
스타트는 런을 호출, (->4번으로




MAIN( A REF)
쓰레드부터 생성.
숨어있는 디폴트생성자의 SUPER생성

그 다음 a를 생성 run()재정의
4번
run( );
다시 돌아감

(***시험문제 : 추상클래스는 new로 원래 못만듬.)
	* 
추상클래스라는게 조건이 클래스 자체를 abstract를 만들거나
	* 
추상메서드가 있어야 추상클래스인데
	* 
추상메서드없이 추상클래스로 만든 이유로 만든 이유는?
	* 
그 클래스는 new를 생성해서 쓰는게 아니라 상속해서 쓰게 만드는 것.
	* 
추상메서드가 없어도 추상클래스를 만든다. 그래서 상속을 해야만 쓸 수 있는거고 그렇게 설계할려고 만든 것.





스레드는 추상클래스가 아니라 일반클래스이므로 new를 쓴다.
	* 
일반클래스는 이렇게 알 수 잇다. (New확인)





